# ================================================================
# Crusher - Health Checks
# ================================================================
# "I'm a doctor, not a..." - Monitors pipeline and application health
# Retrieves health data from CI pipelines and deployed applications
# ================================================================

name: Crusher - Health

on:
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to check'
        required: true
        default: 'dev'
        type: choice
        options: [dev, prod, all]
      check_type:
        description: 'Type of health check'
        required: true
        default: 'all'
        type: choice
        options: [all, application, infrastructure, pipeline, container]

permissions:
  contents: read
  actions: read
  checks: read
  packages: read

env:
  APP_URL_DEV: ${{ vars.APP_URL_DEV || 'https://dev.example.com' }}
  APP_URL_PROD: ${{ vars.APP_URL_PROD || 'https://staging.princetonstrong.com' }}

jobs:
  # ══════════════════════════════════════════════════════════════════════════
  # Pipeline Health: Check recent workflow runs
  # ══════════════════════════════════════════════════════════════════════════
  pipeline-health:
    name: Pipeline Health
    runs-on: ubuntu-latest
    if: |
      github.event.inputs.check_type == 'all' ||
      github.event.inputs.check_type == 'pipeline'
    outputs:
      status: ${{ steps.check.outputs.status }}
      summary: ${{ steps.check.outputs.summary }}
    steps:
      - name: Check Pipeline Status
        id: check
        uses: actions/github-script@v7
        with:
          script: |
            const workflows = [
              { name: 'Data - CI', file: 'data.yml' },
              { name: 'Picard - Build', file: 'picard.yml' },
              { name: 'Riker - Release', file: 'riker.yml' },
              { name: 'Worf - Security', file: 'worf.yml' },
              { name: 'La Forge - Deploy', file: 'laforge.yml' }
            ];

            let healthy = 0;
            let unhealthy = 0;
            let results = [];

            for (const wf of workflows) {
              try {
                const runs = await github.rest.actions.listWorkflowRuns({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  workflow_id: wf.file,
                  per_page: 1
                });

                if (runs.data.workflow_runs.length > 0) {
                  const run = runs.data.workflow_runs[0];
                  const status = run.conclusion || run.status;
                  const isHealthy = status === 'success' || status === 'in_progress';

                  if (isHealthy) healthy++;
                  else unhealthy++;

                  results.push({
                    name: wf.name,
                    status: status,
                    healthy: isHealthy,
                    url: run.html_url,
                    updated: run.updated_at
                  });
                }
              } catch (e) {
                results.push({
                  name: wf.name,
                  status: 'unknown',
                  healthy: false,
                  error: e.message
                });
                unhealthy++;
              }
            }

            const overallStatus = unhealthy === 0 ? 'healthy' : (healthy > unhealthy ? 'degraded' : 'unhealthy');

            core.setOutput('status', overallStatus);
            core.setOutput('summary', JSON.stringify(results));

            return { status: overallStatus, results };

      - name: Pipeline Summary
        run: |
          {
            echo "## Crusher - Pipeline Health"
            echo ""
            echo "| Workflow | Status | Last Run |"
            echo "|----------|--------|----------|"
            echo '${{ steps.check.outputs.summary }}' | jq -r '.[] | "| \(.name) | \(if .healthy then "OK" else "FAIL" end) | \(.updated // "N/A") |"'
            echo ""
            echo "**Overall Status:** ${{ steps.check.outputs.status }}"
          } >> "$GITHUB_STEP_SUMMARY"

  # ══════════════════════════════════════════════════════════════════════════
  # Container Health: Check GHCR image status
  # ══════════════════════════════════════════════════════════════════════════
  container-health:
    name: Container Health
    runs-on: ubuntu-latest
    if: |
      github.event.inputs.check_type == 'all' ||
      github.event.inputs.check_type == 'container'
    outputs:
      status: ${{ steps.check.outputs.status }}
    steps:
      - name: Check GHCR images
        id: check
        uses: actions/github-script@v7
        with:
          script: |
            const tags = ['latest', 'prod', 'dev'];
            const pkg = 'witness';
            let results = [];
            let healthy = 0;
            let unhealthy = 0;

            for (const tag of tags) {
              try {
                const versions = await github.rest.packages.getAllPackageVersionsForPackageOwnedByOrg({
                  package_type: 'container',
                  package_name: pkg,
                  org: context.repo.owner,
                  per_page: 100
                });

                const match = versions.data.find(v =>
                  v.metadata?.container?.tags?.includes(tag)
                );

                if (match) {
                  healthy++;
                  results.push({
                    tag,
                    status: 'found',
                    healthy: true,
                    updated: match.updated_at,
                    digest: match.name?.substring(0, 19) || 'unknown'
                  });
                } else {
                  unhealthy++;
                  results.push({
                    tag,
                    status: 'missing',
                    healthy: false,
                    updated: null,
                    digest: null
                  });
                }
              } catch (e) {
                try {
                  const versions = await github.rest.packages.getAllPackageVersionsForPackageOwnedByUser({
                    package_type: 'container',
                    package_name: pkg,
                    username: context.repo.owner,
                    per_page: 100
                  });

                  const match = versions.data.find(v =>
                    v.metadata?.container?.tags?.includes(tag)
                  );

                  if (match) {
                    healthy++;
                    results.push({
                      tag,
                      status: 'found',
                      healthy: true,
                      updated: match.updated_at,
                      digest: match.name?.substring(0, 19) || 'unknown'
                    });
                  } else {
                    unhealthy++;
                    results.push({
                      tag,
                      status: 'missing',
                      healthy: false,
                      updated: null,
                      digest: null
                    });
                  }
                } catch (e2) {
                  unhealthy++;
                  results.push({
                    tag,
                    status: 'error',
                    healthy: false,
                    error: e2.message
                  });
                }
              }
            }

            const overallStatus = unhealthy === 0 ? 'healthy' : (healthy > unhealthy ? 'degraded' : 'unhealthy');

            core.setOutput('status', overallStatus);
            core.setOutput('summary', JSON.stringify(results));

      - name: Container Summary
        run: |
          {
            echo "## Crusher - Container Health (GHCR)"
            echo ""
            echo "| Tag | Status | Last Updated | Digest |"
            echo "|-----|--------|-------------|--------|"
            echo '${{ steps.check.outputs.summary }}' | jq -r '.[] | "| \(.tag) | \(if .healthy then "OK" else "MISSING" end) | \(.updated // "N/A") | \(.digest // "N/A") |"'
            echo ""
            echo "**Registry:** \`ghcr.io/${{ github.repository_owner }}/witness\`"
            echo ""
            echo "**Overall Status:** ${{ steps.check.outputs.status }}"
          } >> "$GITHUB_STEP_SUMMARY"

  # ══════════════════════════════════════════════════════════════════════════
  # Application Health: Check deployed application endpoints
  # ══════════════════════════════════════════════════════════════════════════
  application-health:
    name: Application Health
    runs-on: ubuntu-latest
    if: |
      github.event.inputs.check_type == 'all' ||
      github.event.inputs.check_type == 'application'
    strategy:
      fail-fast: false
      matrix:
        include:
          - env: dev
            url: ${{ vars.APP_URL_DEV || 'https://dev.example.com' }}
          - env: prod
            url: ${{ vars.APP_URL_PROD || 'https://engage.princetonstrong.com' }}
        exclude:
          - env: ${{ github.event.inputs.environment == 'prod' && 'dev' || (github.event.inputs.environment == 'dev' && 'prod' || '') }}
    outputs:
      dev_status: ${{ steps.health.outputs.dev_status }}
      prod_status: ${{ steps.health.outputs.prod_status }}
    steps:
      - name: Check Health Endpoint
        id: health
        run: |
          URL="${{ matrix.url }}"
          ENV="${{ matrix.env }}"

          echo "Checking health for $ENV environment: $URL"

          HEALTHZ_STATUS=$(curl -s -o /dev/null -w "%{http_code}" --max-time 10 "${URL}/healthz" 2>/dev/null || echo "000")
          READYZ_STATUS=$(curl -s -o /dev/null -w "%{http_code}" --max-time 10 "${URL}/readyz" 2>/dev/null || echo "000")
          MAIN_STATUS=$(curl -s -o /dev/null -w "%{http_code}" --max-time 10 "${URL}/" 2>/dev/null || echo "000")
          HEALTHZ_TIME=$(curl -s -o /dev/null -w "%{time_total}" --max-time 10 "${URL}/healthz" 2>/dev/null || echo "0")

          if [ "$HEALTHZ_STATUS" = "200" ] && [ "$READYZ_STATUS" = "200" ]; then
            STATUS="healthy"
          elif [ "$HEALTHZ_STATUS" = "200" ]; then
            STATUS="degraded"
          else
            STATUS="unhealthy"
          fi

          echo "${ENV}_status=${STATUS}" >> "$GITHUB_OUTPUT"
          echo "healthz_code=${HEALTHZ_STATUS}" >> "$GITHUB_OUTPUT"
          echo "readyz_code=${READYZ_STATUS}" >> "$GITHUB_OUTPUT"
          echo "main_code=${MAIN_STATUS}" >> "$GITHUB_OUTPUT"
          echo "response_time=${HEALTHZ_TIME}" >> "$GITHUB_OUTPUT"
        continue-on-error: true

      - name: Application Summary
        if: always()
        run: |
          {
            echo "## Crusher - Application Health: ${{ matrix.env }}"
            echo ""
            echo "| Endpoint | Status | Code |"
            echo "|----------|--------|------|"
            echo "| /healthz | ${{ steps.health.outputs.healthz_code == '200' && 'OK' || 'FAIL' }} | ${{ steps.health.outputs.healthz_code }} |"
            echo "| /readyz | ${{ steps.health.outputs.readyz_code == '200' && 'OK' || 'FAIL' }} | ${{ steps.health.outputs.readyz_code }} |"
            echo "| / | ${{ steps.health.outputs.main_code == '200' && 'OK' || 'FAIL' }} | ${{ steps.health.outputs.main_code }} |"
            echo ""
            echo "**Response Time:** ${{ steps.health.outputs.response_time }}s"
            echo ""
            echo "**Overall Status:** ${{ steps.health.outputs.dev_status || steps.health.outputs.prod_status || 'unknown' }}"
          } >> "$GITHUB_STEP_SUMMARY"

  # ══════════════════════════════════════════════════════════════════════════
  # Infrastructure Health: Check Terraform state
  # ══════════════════════════════════════════════════════════════════════════
  infrastructure-health:
    name: Infrastructure Health
    runs-on: ubuntu-latest
    if: |
      vars.ENABLE_TERRAFORM != 'false' &&
      (github.event.inputs.check_type == 'all' ||
       github.event.inputs.check_type == 'infrastructure')
    env:
      TF_API_TOKEN: ${{ secrets.TF_API_TOKEN }}
      TF_ORG: ${{ vars.TF_CLOUD_ORG }}
    steps:
      - name: Check HCP Terraform Workspaces
        id: workspaces
        run: |
          for ENV in dev prod; do
            WS="witness-${ENV}"
            RESPONSE=$(curl -s \
              --header "Authorization: Bearer ${TF_API_TOKEN}" \
              "https://app.terraform.io/api/v2/organizations/${TF_ORG}/workspaces/${WS}" 2>/dev/null)

            RESOURCE_COUNT=$(echo "$RESPONSE" | jq -r '.data.attributes["resource-count"] // 0')
            CURRENT_RUN=$(echo "$RESPONSE" | jq -r '.data.relationships["current-run"].data.id // "none"')

            if [ "$CURRENT_RUN" != "none" ] && [ "$CURRENT_RUN" != "null" ]; then
              RUN_STATUS=$(curl -s \
                --header "Authorization: Bearer ${TF_API_TOKEN}" \
                "https://app.terraform.io/api/v2/runs/${CURRENT_RUN}" \
                | jq -r '.data.attributes.status // "unknown"')
            else
              RUN_STATUS="no-runs"
            fi

            echo "${ENV}_resources=${RESOURCE_COUNT}" >> "$GITHUB_OUTPUT"
            echo "${ENV}_status=${RUN_STATUS}" >> "$GITHUB_OUTPUT"
          done
        continue-on-error: true

      - name: Infrastructure Summary
        if: always()
        run: |
          {
            echo "## Crusher - Infrastructure Health (HCP Terraform / AWS)"
            echo ""
            echo "| Workspace | Last Run Status | Resources |"
            echo "|-----------|-----------------|-----------|"
            echo "| witness-dev | ${{ steps.workspaces.outputs.dev_status || 'unknown' }} | ${{ steps.workspaces.outputs.dev_resources || '0' }} |"
            echo "| witness-prod | ${{ steps.workspaces.outputs.prod_status || 'unknown' }} | ${{ steps.workspaces.outputs.prod_resources || '0' }} |"
          } >> "$GITHUB_STEP_SUMMARY"

  # ══════════════════════════════════════════════════════════════════════════
  # Health Report: Aggregate all health data
  # ══════════════════════════════════════════════════════════════════════════
  health-report:
    name: Health Report
    runs-on: ubuntu-latest
    needs: [pipeline-health, container-health, application-health, infrastructure-health]
    if: always()
    steps:
      - name: Generate Health Report
        run: |
          {
            echo "## Crusher - Health Report"
            echo ""
            echo "**Generated:** $(date -u +%Y-%m-%dT%H:%M:%SZ)"
            echo ""
            echo "### Summary"
            echo ""
            echo "| Component | Status |"
            echo "|-----------|--------|"
            echo "| Pipeline | ${{ needs.pipeline-health.outputs.status || 'skipped' }} |"
            echo "| Container (GHCR) | ${{ needs.container-health.outputs.status || 'skipped' }} |"
            echo "| App (dev) | ${{ needs.application-health.outputs.dev_status || 'skipped' }} |"
            echo "| App (prod) | ${{ needs.application-health.outputs.prod_status || 'skipped' }} |"
            echo ""

            PIPELINE="${{ needs.pipeline-health.outputs.status }}"
            CONTAINER="${{ needs.container-health.outputs.status }}"
            APP_PROD="${{ needs.application-health.outputs.prod_status }}"

            if [ "$PIPELINE" = "healthy" ] && [ "$CONTAINER" = "healthy" ] && [ "$APP_PROD" = "healthy" ]; then
              echo "### Overall: HEALTHY"
            elif [ "$PIPELINE" = "unhealthy" ] || [ "$CONTAINER" = "unhealthy" ] || [ "$APP_PROD" = "unhealthy" ]; then
              echo "### Overall: UNHEALTHY"
            else
              echo "### Overall: DEGRADED"
            fi
          } >> "$GITHUB_STEP_SUMMARY"

      - name: Alert on Unhealthy
        if: |
          needs.pipeline-health.outputs.status == 'unhealthy' ||
          needs.container-health.outputs.status == 'unhealthy' ||
          needs.application-health.outputs.prod_status == 'unhealthy'
        run: |
          echo "::error::Health check failed! Pipeline: ${{ needs.pipeline-health.outputs.status }}, Container: ${{ needs.container-health.outputs.status }}, App: ${{ needs.application-health.outputs.prod_status }}"
