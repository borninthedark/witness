# ══════════════════════════════════════════════════════════════════════════════
# Captain's Fitness Log - Kubernetes Deployment Manifest
# ══════════════════════════════════════════════════════════════════════════════
#
# DEPLOYMENT TARGET: Azure Kubernetes Service (AKS)
# INGRESS: Azure App Routing add-on (managed NGINX controller)
# CERT MANAGEMENT: cert-manager with Let's Encrypt cluster issuer
#
# ──────────────────────────────────────────────────────────────────────────────
# SETUP INSTRUCTIONS
# ──────────────────────────────────────────────────────────────────────────────
#
# 1. GHCR SECRET CONFIGURATION:
#    a. Create GitHub PAT at https://github.com/settings/tokens
#       with 'read:packages' scope
#    b. Run this command to generate the base64 string:
#       echo -n '{"auths":{"ghcr.io":{"username":"YOUR_USERNAME",
#         "password":"YOUR_PAT","email":"your@email.com",
#         "auth":"'$(echo -n 'YOUR_USERNAME:YOUR_PAT' | base64)'"}}}' \
#         | base64 -w 0
#    c. Replace PASTE_BASE64_ENCODED_DOCKER_CONFIG_HERE below with output
#
# 2. APPLICATION SECRETS:
#    Update the DATABASE_URL and SECRET_KEY in the fitness-secrets Secret
#
# 3. CERT-MANAGER SETUP:
#    Apply the Let's Encrypt cluster issuer first:
#    kubectl apply -f k8s/lets-encrypt-issuer.yaml
#
# 4. DEPLOYMENT:
#    kubectl apply -f k8s/deploy.yaml
#
# ══════════════════════════════════════════════════════════════════════════════
---
# ──────────────────────────────────────────────────────────────────────────────
# NAMESPACE
# ──────────────────────────────────────────────────────────────────────────────
apiVersion: v1
kind: Namespace
metadata:
  name: fitness
  labels:
    name: fitness
    app.kubernetes.io/name: fitness

---
# ──────────────────────────────────────────────────────────────────────────────
# SECRETS
# ──────────────────────────────────────────────────────────────────────────────

# GHCR Docker Registry Secret
apiVersion: v1
kind: Secret
metadata:
  name: ghcr-secret
  namespace: fitness
type: kubernetes.io/dockerconfigjson
data:
  .dockerconfigjson: SUPER-SECRET-KEY

---
# Application Secrets
# WARNING: These are example values. Replace with actual secrets in production.
# For production, use Azure Key Vault or Kubernetes External Secrets Operator.
apiVersion: v1
kind: Secret
metadata:
  name: fitness-secrets
  namespace: fitness
type: Opaque
stringData:
  DATABASE_URL: "sqlite:////app/data/fitness.db"
  SECRET_KEY: "4D*Ve!1x*xC%"  # Replace with a secure random key

---
# ──────────────────────────────────────────────────────────────────────────────
# STORAGE
# ──────────────────────────────────────────────────────────────────────────────

# Persistent Volume Claim for SQLite database
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: fitness-data-pvc
  namespace: fitness
spec:
  accessModes: ["ReadWriteOnce"]
  resources:
    requests:
      storage: 10Gi
  storageClassName: managed-csi  # AKS default storage class

---
# ──────────────────────────────────────────────────────────────────────────────
# WORKLOAD - DEPLOYMENT
# ──────────────────────────────────────────────────────────────────────────────
apiVersion: apps/v1
kind: Deployment
metadata:
  name: fitness-app
  namespace: fitness
  labels:
    app: fitness
    app.kubernetes.io/name: fitness
    app.kubernetes.io/component: web
spec:
  replicas: 1
  selector:
    matchLabels:
      app: fitness
  template:
    metadata:
      labels:
        app: fitness
    spec:
      securityContext:
        fsGroup: 1000
      imagePullSecrets:
        - name: ghcr-secret
      volumes:
        - name: data
          persistentVolumeClaim:
            claimName: fitness-data-pvc
      initContainers:
        - name: init-db
          image: busybox:1.36
          command: ['sh', '-c']
          args:
            - |
              mkdir -p /app/data
              touch /app/data/fitness.db
              chown -R 1000:1000 /app/data
              chmod 775 /app/data
              chmod 664 /app/data/fitness.db
              ls -la /app/data
              echo "Database directory initialized with write permissions"
          volumeMounts:
            - name: data
              mountPath: /app/data
          securityContext:
            runAsUser: 0
      containers:
        - name: app
          image: ghcr.io/borninthedark/witness:latest
          imagePullPolicy: Always
          ports:
            - name: http
              containerPort: 8000
              protocol: TCP
          env:
            - name: DATABASE_URL
              valueFrom:
                secretKeyRef:
                  name: fitness-secrets
                  key: DATABASE_URL
            - name: SECRET_KEY
              valueFrom:
                secretKeyRef:
                  name: fitness-secrets
                  key: SECRET_KEY
            - name: WEB_WORKERS
              value: "4"
            - name: LOG_LEVEL
              value: "info"
            - name: PYTHONUNBUFFERED
              value: "1"
          # Health Checks
          livenessProbe:
            httpGet:
              path: /healthz
              port: http
              scheme: HTTP
            initialDelaySeconds: 30
            periodSeconds: 15
            timeoutSeconds: 5
            successThreshold: 1
            failureThreshold: 3
          readinessProbe:
            httpGet:
              path: /readyz
              port: http
              scheme: HTTP
            initialDelaySeconds: 10
            periodSeconds: 10
            timeoutSeconds: 5
            successThreshold: 1
            failureThreshold: 3
          startupProbe:
            httpGet:
              path: /healthz
              port: http
              scheme: HTTP
            initialDelaySeconds: 5
            periodSeconds: 5
            timeoutSeconds: 3
            successThreshold: 1
            failureThreshold: 12  # Allow up to 60 seconds for startup
          # Resource Limits
          resources:
            requests:
              cpu: 50m
              memory: 256Mi
            limits:
              cpu: "1"
              memory: 512Mi
          # Volume Mounts
          volumeMounts:
            - name: data
              mountPath: /app/data
          # Security Context
          securityContext:
            allowPrivilegeEscalation: false
            readOnlyRootFilesystem: false  # App needs to write to /app/data
            runAsNonRoot: true
            runAsUser: 1000
            capabilities:
              drop:
                - ALL

---
# ──────────────────────────────────────────────────────────────────────────────
# SERVICE - INTERNAL LOAD BALANCER
# ──────────────────────────────────────────────────────────────────────────────
apiVersion: v1
kind: Service
metadata:
  name: fitness-service
  namespace: fitness
  labels:
    app: fitness
    app.kubernetes.io/name: fitness
    app.kubernetes.io/component: web
spec:
  type: ClusterIP
  selector:
    app: fitness
  ports:
    - name: http
      port: 80
      targetPort: 8000
      protocol: TCP

---
# ──────────────────────────────────────────────────────────────────────────────
# INGRESS - TLS-ENABLED EXTERNAL ACCESS
# ──────────────────────────────────────────────────────────────────────────────
# Uses Azure App Routing add-on (managed NGINX ingress controller)
# Automatic TLS certificate provisioning via cert-manager + Let's Encrypt
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: fitness-ingress
  namespace: fitness
  labels:
    app: fitness
    app.kubernetes.io/name: fitness
  annotations:
    # cert-manager will automatically provision and renew TLS certificate
    cert-manager.io/cluster-issuer: letsencrypt-prod
    # NGINX ingress configuration
    nginx.ingress.kubernetes.io/rewrite-target: /
    nginx.ingress.kubernetes.io/ssl-redirect: "true"
    nginx.ingress.kubernetes.io/force-ssl-redirect: "true"
spec:
  ingressClassName: webapprouting.kubernetes.azure.com
  rules:
    - host: engage.princetonstrong.online
      http:
        paths:
          - path: /
            pathType: Prefix
            backend:
              service:
                name: fitness-service
                port:
                  number: 80
  tls:
    - hosts:
        - engage.princetonstrong.online
      secretName: fitness-tls

---
# ──────────────────────────────────────────────────────────────────────────────
# AUTOSCALING - HORIZONTAL POD AUTOSCALER
# ──────────────────────────────────────────────────────────────────────────────
# Automatically scales replicas based on CPU and memory utilization
# Requires metrics-server to be installed in the cluster (enabled by default in AKS)
apiVersion: autoscaling/v2
kind: HorizontalPodAutoscaler
metadata:
  name: fitness-hpa
  namespace: fitness
  labels:
    app: fitness
    app.kubernetes.io/name: fitness
spec:
  scaleTargetRef:
    apiVersion: apps/v1
    kind: Deployment
    name: fitness-app
  minReplicas: 1
  maxReplicas: 1
  metrics:
    - type: Resource
      resource:
        name: cpu
        target:
          type: Utilization
          averageUtilization: 70
    - type: Resource
      resource:
        name: memory
        target:
          type: Utilization
          averageUtilization: 80
